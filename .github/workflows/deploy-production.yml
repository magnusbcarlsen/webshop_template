name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 30 # Increased timeout

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy to Digital Ocean
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_SERVER_IP }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT || 22 }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 25m # Increased SSH timeout
          command_timeout: 20m # Increased command timeout
          script_stop: false # Don't stop on individual command failures
          script: |
            set -e

            echo "ğŸš€ Starting resilient deployment..."

            # Navigate to app directory
            cd /var/www/webshop

            # Pull latest code
            echo "ğŸ“¥ Pulling latest code..."
            timeout 120 git fetch origin || echo "Git fetch timeout, continuing..."
            timeout 60 git reset --hard origin/main || echo "Git reset timeout, continuing..."

            # Clean workspace
            echo "ğŸ§¹ Cleaning workspace..."
            git clean -fd -e certbot/ || echo "Git clean completed with warnings"

            # Create environment file FIRST (before building)
            echo "âš™ï¸ Setting up environment..."
            cat > .env << 'ENVEOF'
            NODE_ENV=production
            ENVIRONMENT=production

            # Database Configuration
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
            MYSQL_PORT=3306

            # Backend Database Connection
            DB_HOST=db
            DB_PORT=3306
            DB_USER=${{ secrets.MYSQL_USER }}
            DB_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            DB_NAME=${{ secrets.MYSQL_DATABASE }}
            DB_USERNAME=${{ secrets.MYSQL_USER }}
            DB_DATABASE=${{ secrets.MYSQL_DATABASE }}

            # Backend Configuration
            PORT=3001
            FRONTEND_URL=https://${{ secrets.DOMAIN }}

            # Frontend Configuration
            BACKEND_URL=http://backend:3001
            NEXT_PUBLIC_API_URL=/api
            NEXT_PUBLIC_API_BASE_URL=https://${{ secrets.DOMAIN }}

            # Security
            JWT_SECRET=${{ secrets.JWT_SECRET }}

            # Stripe Configuration
            STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
            WEBHOOK_SECRET=${{ secrets.WEBHOOK_SECRET }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

            # MinIO Configuration
            MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
            MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}

            # MinIO URLs
            MINIO_API_HOST=${{ secrets.DOMAIN }}
            MINIO_API_PORT=443
            NEXT_PUBLIC_MINIO_PUBLIC_URL=https://${{ secrets.DOMAIN }}

            # S3-Compatible Settings
            do_spaces_endpoint=http://minio:9000
            do_spaces_region=us-east-1
            do_spaces_bucket=${{ secrets.MINIO_BUCKET }}
            do_spaces_key=${{ secrets.MINIO_ROOT_USER }}
            do_spaces_secret=${{ secrets.MINIO_ROOT_PASSWORD }}

            # MinIO Bucket
            MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}

            # Domain
            DOMAIN=${{ secrets.DOMAIN }}

            # Optimized Node.js Settings for 1GB server
            NODE_OPTIONS=--max-old-space-size=1024
            NEXT_TELEMETRY_DISABLED=1
            ENVEOF

            chmod 600 .env

            echo "ğŸ”§ Configuration ready..."

            # Create swap file if not exists (helps with memory)
            if [ ! -f /swapfile ]; then
              echo "ğŸ’¾ Creating swap file for build process..."
              sudo fallocate -l 1G /swapfile || echo "Swap creation failed, continuing..."
              sudo chmod 600 /swapfile || true
              sudo mkswap /swapfile || true
              sudo swapon /swapfile || true
            fi

            # Check system resources
            echo "ğŸ’¾ System resources before deployment:"
            free -h || echo "Memory check failed"
            df -h / || echo "Disk check failed"

            # Stop services gracefully
            echo "ğŸ›‘ Stopping services..."
            timeout 120 docker compose -f docker-compose.prod.yml down --remove-orphans || echo "Stop completed with timeout"

            # Minimal cleanup to avoid hanging
            echo "ğŸ§¹ Quick cleanup..."
            timeout 60 docker system prune -f || echo "Cleanup completed with timeout"

            # Build services - simplified approach
            echo "ğŸ—ï¸ Building services..."

            # Build with no cache to ensure fresh build with new environment variables
            timeout 600 docker compose -f docker-compose.prod.yml build --no-cache || {
              echo "âš ï¸ Build timeout - trying alternative approach..."
              timeout 300 docker compose -f docker-compose.prod.yml pull || echo "Pull completed with timeout"
              timeout 300 docker compose -f docker-compose.prod.yml build --no-cache backend || echo "Backend build timeout"
              timeout 300 docker compose -f docker-compose.prod.yml build --no-cache frontend || echo "Frontend build timeout"
            }

            # Start services with timeout protection
            echo "ğŸš€ Starting services..."
            timeout 180 docker compose -f docker-compose.prod.yml up -d || {
              echo "âš ï¸ Startup timeout - checking what's running..."
              docker compose -f docker-compose.prod.yml ps
            }

            # Wait and check
            echo "â³ Waiting for services..."
            sleep 30

            # Simple health check
            echo "ğŸ¥ Health check..."
            for i in {1..5}; do
              if timeout 5 curl -f http://localhost/health >/dev/null 2>&1; then
                echo "âœ… Health check passed!"
                break
              else
                echo "Attempt $i/5 failed, waiting..."
                sleep 10
              fi
            done

            # Final status regardless of health check
            echo "ğŸ“Š Final status:"
            docker compose -f docker-compose.prod.yml ps || echo "Status check failed"

            echo "ğŸ‰ Deployment completed!"
            echo "ğŸŒ Application: https://${{ secrets.DOMAIN }}"
            echo "ğŸ“ Check application manually if health check failed"
