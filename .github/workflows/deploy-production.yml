name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 25 # Increased for full build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DO_SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Deploy to Digital Ocean
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_SERVER_IP }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT || 22 }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 20m # Increased for full build
          command_timeout: 15m
          script_stop: false
          script: |
            set -e

            echo "ğŸš€ Starting optimal full deployment..."

            # Navigate to app directory
            cd /var/www/webshop

            # Pull latest code
            echo "ğŸ“¥ Pulling latest code..."
            git fetch origin
            git reset --hard origin/main

            # Clean git workspace but exclude certbot directories
            echo "ğŸ§¹ Cleaning workspace (excluding certbot)..."
            git clean -fd -e certbot/

            # Create production environment file
            echo "âš™ï¸ Setting up environment..."
            cat > .env << ENVEOF
            NODE_ENV=production
            ENVIRONMENT=production

            # Database Configuration
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
            MYSQL_PORT=3306

            # Backend Database Connection
            DB_HOST=db
            DB_PORT=3306
            DB_USER=${{ secrets.MYSQL_USER }}
            DB_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            DB_NAME=${{ secrets.MYSQL_DATABASE }}
            DB_USERNAME=${{ secrets.MYSQL_USER }}
            DB_DATABASE=${{ secrets.MYSQL_DATABASE }}

            # Backend Configuration
            PORT=3001
            FRONTEND_URL=https://${{ secrets.DOMAIN }}

            # Frontend Configuration
            BACKEND_URL=http://backend:3001
            NEXT_PUBLIC_API_URL=/api
            NEXT_PUBLIC_API_BASE_URL=https://${{ secrets.DOMAIN }}

            # Security
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            CSRF_SECRET=${{ secrets.CSRF_SECRET }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}

            # Stripe Configuration
            STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
            WEBHOOK_SECRET=${{ secrets.WEBHOOK_SECRET }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}

            # MinIO Configuration
            MINIO_ROOT_USER=${{ secrets.MINIO_ROOT_USER }}
            MINIO_ROOT_PASSWORD=${{ secrets.MINIO_ROOT_PASSWORD }}

            # MinIO URLs
            MINIO_API_HOST=${{ secrets.DOMAIN }}
            MINIO_API_PORT=443
            NEXT_PUBLIC_MINIO_PUBLIC_URL=https://${{ secrets.DOMAIN }}

            # S3-Compatible Settings
            do_spaces_endpoint=http://minio:9000
            do_spaces_region=us-east-1
            do_spaces_bucket=${{ secrets.MINIO_BUCKET }}
            do_spaces_key=${{ secrets.MINIO_ROOT_USER }}
            do_spaces_secret=${{ secrets.MINIO_ROOT_PASSWORD }}

            # MinIO Bucket
            MINIO_BUCKET=${{ secrets.MINIO_BUCKET }}

            # Domain
            DOMAIN=${{ secrets.DOMAIN }}

            # Node.js Settings - Optimized for 1GB server
            NODE_OPTIONS=--max-old-space-size=1536
            NEXT_TELEMETRY_DISABLED=1
            ENVEOF

            # Secure the .env file
            chmod 600 .env

            echo "ğŸ”§ Nginx configuration ready..."

            # Stop services and free up memory
            echo "ğŸ›‘ Stopping services..."
            docker compose -f docker-compose.prod.yml down --remove-orphans

            # Aggressive cleanup to free maximum memory
            echo "ğŸ§¹ Aggressive cleanup for optimal build..."
            docker system prune -af --volumes
            docker builder prune -af

            # Clear any lingering processes
            pkill -f node || true

            # Check available memory
            echo "ğŸ’¾ Available memory before build:"
            free -h

            # Optimal build strategy: Build services individually to manage memory
            echo "ğŸ—ï¸ Building services optimally..."

            # Build backend first (smaller, faster)
            echo "ğŸ“¦ Building backend..."
            docker compose -f docker-compose.prod.yml build --no-cache backend

            # Clear build cache between builds
            docker builder prune -f

            # Build frontend with memory optimization
            echo "ğŸ“¦ Building frontend with memory optimization..."
            # Set Docker to use swap and limit concurrent builds
            export DOCKER_BUILDKIT=0  # Use legacy builder for better memory management
            docker compose -f docker-compose.prod.yml build --no-cache frontend

            # Re-enable BuildKit for future operations
            export DOCKER_BUILDKIT=1

            # Start database and supporting services first
            echo "ğŸ—„ï¸ Starting database and support services..."
            docker compose -f docker-compose.prod.yml up -d db minio

            # Wait for database to be ready
            echo "â³ Waiting for database..."
            sleep 20

            # Start backend
            echo "ğŸ”§ Starting backend..."
            docker compose -f docker-compose.prod.yml up -d backend

            # Wait for backend to initialize
            echo "â³ Waiting for backend..."
            sleep 15

            # Start frontend
            echo "ğŸ¨ Starting frontend..."
            docker compose -f docker-compose.prod.yml up -d frontend

            # Wait for frontend
            echo "â³ Waiting for frontend..."
            sleep 10

            # Start nginx last
            echo "ğŸŒ Starting nginx..."
            docker compose -f docker-compose.prod.yml up -d nginx

            # Final wait for all services
            echo "â³ Final service startup wait..."
            sleep 15

            # Quick health check
            echo "ğŸ¥ Running optimized health check..."
            max_attempts=10
            attempt=1

            while [ $attempt -le $max_attempts ]; do
              if curl -f --max-time 3 http://localhost/health > /dev/null 2>&1; then
                echo "âœ… Health check passed!"
                break
              fi
              
              if [ $attempt -eq $max_attempts ]; then
                echo "âš ï¸ Health check timeout - checking service status..."
                docker compose -f docker-compose.prod.yml ps
                echo "ğŸŒ Application should be available at: https://${{ secrets.DOMAIN }}"
                echo "â³ Services may still be starting up..."
                break
              fi
              
              echo "Attempt $attempt/$max_attempts, retrying in 3s..."
              sleep 3
              attempt=$((attempt + 1))
            done

            # Final status
            echo "ğŸ“Š Final service status:"
            docker compose -f docker-compose.prod.yml ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"

            echo "ğŸ‰ Optimal deployment completed!"
            echo "ğŸŒ Application: https://${{ secrets.DOMAIN }}"
            echo "ğŸ›¡ï¸ CSRF Protection: ENABLED"
            echo "ğŸ’¾ Memory usage after deployment:"
            free -h
